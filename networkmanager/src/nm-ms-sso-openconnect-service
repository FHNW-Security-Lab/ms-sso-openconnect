#!/usr/bin/env python3
"""NetworkManager VPN service for MS SSO OpenConnect.

This service implements a NetworkManager VPN plugin using libnm's
NM.VpnServicePlugin base class.

Connection flow:
- Read VPN config + secrets from the NM connection
- Use the existing `ms-sso-openconnect.py` Playwright-based SSO logic to obtain cookies
- Start `openconnect` with those cookies and a vpnc-script style helper
  (`nm-ms-sso-openconnect-service-openconnect-helper`) that reports tunnel
  configuration back to NetworkManager via D-Bus.
"""

from __future__ import annotations

import importlib.util
import json
import os
import re
import signal
import subprocess
import sys
import threading
import time
from pathlib import Path
from typing import Any, Optional

import gi

gi.require_version("NM", "1.0")
from gi.repository import GLib, NM  # noqa: E402


SERVICE_NAME = "org.freedesktop.NetworkManager.ms-sso-openconnect"

DATA_KEY_GATEWAY = "gateway"
DATA_KEY_PROTOCOL = "protocol"
DATA_KEY_USERNAME = "username"
DATA_KEY_NO_DTLS = "no-dtls"

SECRET_KEY_PASSWORD = "password"
SECRET_KEY_TOTP_SECRET = "totp-secret"

DEFAULT_PROTOCOL = "anyconnect"

COOKIE_MAX_AGE_HOURS = int(os.environ.get("MS_SSO_OPENCONNECT_COOKIE_MAX_AGE_HOURS", "12"))
CONNECT_TIMEOUT_SECONDS = int(os.environ.get("MS_SSO_OPENCONNECT_CONNECT_TIMEOUT_SECONDS", "60"))

# Bundled venv paths (used by Debian package postinst)
SYSTEM_VENV = Path("/opt/ms-sso-openconnect-nm/venv")
SYSTEM_BROWSERS = Path("/opt/ms-sso-openconnect-nm/browsers")


def _setup_system_venv() -> None:
    if not SYSTEM_VENV.exists():
        return

    for python_ver in SYSTEM_VENV.glob("lib/python*/site-packages"):
        if python_ver.exists() and str(python_ver) not in sys.path:
            sys.path.insert(0, str(python_ver))
            break

    venv_bin = SYSTEM_VENV / "bin"
    if venv_bin.exists():
        current_path = os.environ.get("PATH", "")
        if str(venv_bin) not in current_path:
            os.environ["PATH"] = f"{venv_bin}:{current_path}"

    if SYSTEM_BROWSERS.exists():
        os.environ.setdefault("PLAYWRIGHT_BROWSERS_PATH", str(SYSTEM_BROWSERS))


_setup_system_venv()


def _now_ts() -> str:
    return time.strftime("%Y-%m-%d %H:%M:%S")


def _log(msg: str) -> None:
    print(f"{_now_ts()} [ms-sso-openconnect] {msg}", file=os.sys.stderr, flush=True)


def _load_ms_sso_openconnect_module() -> Any:
    env_override = os.environ.get("MS_SSO_OPENCONNECT_PY")
    candidates: list[Path] = []
    if env_override:
        candidates.append(Path(env_override))

    here = Path(__file__).resolve()
    # If running from the git checkout: networkmanager/src/<this-file> -> repo root
    candidates.append(here.parents[2] / "ms-sso-openconnect.py")

    candidates.extend(
        [
            Path("/usr/share/network-manager-ms-sso-openconnect/ms-sso-openconnect.py"),
            Path("/usr/share/ms-sso-openconnect/ms-sso-openconnect.py"),
            Path("/usr/lib/ms-sso-openconnect/ms-sso-openconnect.py"),
            Path("/usr/local/share/ms-sso-openconnect/ms-sso-openconnect.py"),
            Path("/usr/local/lib/ms-sso-openconnect/ms-sso-openconnect.py"),
        ]
    )

    for path in candidates:
        if not path.exists():
            continue
        spec = importlib.util.spec_from_file_location("ms_sso_openconnect_core", path)
        if spec is None or spec.loader is None:
            continue
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        _log(f"Loaded core module from {path}")
        return module

    raise FileNotFoundError(
        "Cannot find ms-sso-openconnect.py (set MS_SSO_OPENCONNECT_PY or install it)"
    )


def _cache_dir() -> Path:
    # For real installs this should be an appropriate root-owned dir like /var/cache.
    # During development/testing it can be overridden to a writable location.
    return Path(os.environ.get("MS_SSO_OPENCONNECT_NM_CACHE_DIR", "/var/cache/ms-sso-openconnect-nm"))


def _cache_path(connection_uuid: str) -> Path:
    safe_uuid = connection_uuid.replace("/", "_")
    return _cache_dir() / f"session_{safe_uuid}.json"


def _read_cookie_cache(connection_uuid: str) -> Optional[tuple[dict, Optional[str]]]:
    path = _cache_path(connection_uuid)
    if not path.exists():
        return None
    try:
        data = json.loads(path.read_text())
        ts = int(data.get("timestamp", 0))
        if ts <= 0:
            return None
        age_seconds = int(time.time()) - ts
        if age_seconds > COOKIE_MAX_AGE_HOURS * 3600:
            try:
                path.unlink()
            except Exception:
                pass
            return None
        cookies = data.get("cookies")
        if not isinstance(cookies, dict) or not cookies:
            return None
        usergroup = data.get("usergroup")
        if usergroup is not None and not isinstance(usergroup, str):
            usergroup = None
        return cookies, usergroup
    except Exception as exc:
        _log(f"Failed to read cookie cache {path}: {exc}")
        return None


def _write_cookie_cache(connection_uuid: str, cookies: dict, usergroup: Optional[str]) -> None:
    cache_dir = _cache_dir()
    cache_dir.mkdir(parents=True, exist_ok=True)
    path = _cache_path(connection_uuid)
    payload: dict[str, Any] = {"cookies": cookies, "timestamp": int(time.time())}
    if usergroup:
        payload["usergroup"] = usergroup
    path.write_text(json.dumps(payload))
    try:
        os.chmod(path, 0o600)
    except Exception:
        pass


def _ip_config_ready_state(state: NM.VpnServiceState) -> bool:
    return state == NM.VpnServiceState.STARTED


class SsoAuthError(RuntimeError):
    pass


class MsSsoOpenConnectService(NM.VpnServicePlugin):
    def __init__(self):
        super().__init__(service_name=SERVICE_NAME, watch_peer=True)
        self.props.state = NM.VpnServiceState.STOPPED

        self._vpn_core = _load_ms_sso_openconnect_module()
        self._openconnect_process: Optional[subprocess.Popen[str]] = None
        self._openconnect_output_thread: Optional[threading.Thread] = None
        self._connect_thread: Optional[threading.Thread] = None
        self._connect_cancel = threading.Event()
        self._ip_config_event = threading.Event()

        self._active_connection_uuid: Optional[str] = None
        self._active_protocol: Optional[str] = None

        self._portal_cookie_re = re.compile(r"portal-userauthcookie=(\\S+)")

    def do_state_changed(self, state: NM.VpnServiceState) -> None:  # type: ignore[override]
        _log(f"State changed: {int(state)}")

    def do_config(self, config: GLib.Variant) -> None:  # type: ignore[override]
        _log("Received tunnel config from helper")

    def do_ip4_config(self, ip4_config: GLib.Variant) -> None:  # type: ignore[override]
        _log("Received IPv4 config from helper")
        self._ip_config_event.set()
        if not _ip_config_ready_state(self.props.state):
            self.props.state = NM.VpnServiceState.STARTED

    def do_ip6_config(self, config: GLib.Variant) -> None:  # type: ignore[override]
        _log("Received IPv6 config from helper")
        self._ip_config_event.set()
        if not _ip_config_ready_state(self.props.state):
            self.props.state = NM.VpnServiceState.STARTED

    def do_need_secrets(  # type: ignore[override]
        self, connection: NM.Connection, setting_name: str
    ) -> tuple[bool, str]:
        s_vpn = connection.get_setting_vpn()
        if not s_vpn:
            return False, ""

        missing: list[str] = []
        if not s_vpn.get_secret(SECRET_KEY_PASSWORD):
            missing.append(SECRET_KEY_PASSWORD)
        if not s_vpn.get_secret(SECRET_KEY_TOTP_SECRET):
            missing.append(SECRET_KEY_TOTP_SECRET)

        if not missing:
            return False, ""

        return True, NM.SETTING_VPN_SETTING_NAME

    def do_connect(self, connection: NM.Connection) -> bool:  # type: ignore[override]
        if self._connect_thread and self._connect_thread.is_alive():
            _log("Connect already in progress")
            return False

        self._connect_cancel.clear()
        self._ip_config_event.clear()
        self.props.state = NM.VpnServiceState.STARTING

        self._connect_thread = threading.Thread(
            target=self._connect_worker, args=(connection,), name="ms-sso-openconnect-connect", daemon=True
        )
        self._connect_thread.start()
        return True

    def do_connect_interactive(self, connection: NM.Connection, details: GLib.Variant) -> bool:  # type: ignore[override]
        return self.do_connect(connection)

    def do_new_secrets(self, connection: NM.Connection) -> bool:  # type: ignore[override]
        return self.do_connect(connection)

    def do_disconnect(self) -> bool:  # type: ignore[override]
        _log("Disconnect requested")
        self._connect_cancel.set()
        self.props.state = NM.VpnServiceState.STOPPING
        self._terminate_openconnect()
        self.props.state = NM.VpnServiceState.STOPPED
        return True

    def _terminate_openconnect(self) -> None:
        process = self._openconnect_process
        if not process:
            return
        try:
            process.terminate()
            process.wait(timeout=10)
        except Exception:
            try:
                process.kill()
            except Exception:
                pass
        finally:
            self._openconnect_process = None

    def _get_connection_uuid(self, connection: NM.Connection) -> Optional[str]:
        s_con = connection.get_setting_connection()
        if not s_con:
            return None
        uuid = s_con.get_uuid()
        return uuid if uuid else None

    def _connect_worker(self, connection: NM.Connection) -> None:
        try:
            settings = self._parse_connection(connection)
            if not settings:
                raise RuntimeError("Missing or invalid VPN settings")

            connection_uuid = settings["uuid"]
            gateway = settings["gateway"]
            protocol = settings["protocol"]
            username = settings["username"]
            password = settings["password"]
            totp_secret = settings["totp_secret"]
            no_dtls = settings["no_dtls"]

            self._active_connection_uuid = connection_uuid
            self._active_protocol = protocol

            cached = _read_cookie_cache(connection_uuid)
            if cached and not self._connect_cancel.is_set():
                cached_cookies, cached_usergroup = cached
                _log("Trying cached session cookie")
                if self._try_openconnect(
                    connection_uuid=connection_uuid,
                    gateway=gateway,
                    protocol=protocol,
                    username=username,
                    cookies=cached_cookies,
                    cached_usergroup=cached_usergroup,
                    no_dtls=no_dtls,
                ):
                    return
                _log("Cached cookie failed; re-authenticating")
                try:
                    _cache_path(connection_uuid).unlink()
                except Exception:
                    pass

            if self._connect_cancel.is_set():
                return

            _log("Performing Microsoft SSO authentication (Playwright)")
            cookies = self._vpn_core.do_saml_auth(
                gateway,
                username,
                password,
                totp_secret,
                auto_totp=True,
                headless=True,
                debug=False,
            )
            if not cookies:
                raise SsoAuthError("SSO authentication failed (no cookies)")

            cookies.pop("_gateway_ip", None)

            initial_usergroup = "portal:prelogin-cookie" if protocol == "gp" else None
            _write_cookie_cache(connection_uuid, cookies, initial_usergroup)

            if self._connect_cancel.is_set():
                return

            _log("Starting openconnect")
            if not self._try_openconnect(
                connection_uuid=connection_uuid,
                gateway=gateway,
                protocol=protocol,
                username=username,
                cookies=cookies,
                cached_usergroup=initial_usergroup,
                no_dtls=no_dtls,
            ):
                raise RuntimeError("openconnect failed to establish tunnel")
        except Exception as exc:
            _log(f"Connection failed: {exc}")
            failure_reason = (
                NM.VpnPluginFailure.LOGIN_FAILED
                if isinstance(exc, SsoAuthError)
                else NM.VpnPluginFailure.CONNECT_FAILED
            )
            GLib.idle_add(self.failure, failure_reason)
            GLib.idle_add(self._set_stopped)

    def _set_stopped(self) -> None:
        self.props.state = NM.VpnServiceState.STOPPED

    def _try_openconnect(
        self,
        *,
        connection_uuid: str,
        gateway: str,
        protocol: str,
        username: Optional[str],
        cookies: dict,
        cached_usergroup: Optional[str],
        no_dtls: bool,
    ) -> bool:
        self._ip_config_event.clear()

        helper_path = Path(__file__).resolve().with_name(
            "nm-ms-sso-openconnect-service-openconnect-helper"
        )
        if not helper_path.exists():
            helper_path = Path("/usr/libexec/nm-ms-sso-openconnect-service-openconnect-helper")

        cmd, stdin_data = self._build_openconnect_command(
            gateway=gateway,
            protocol=protocol,
            username=username,
            cookies=cookies,
            cached_usergroup=cached_usergroup,
            no_dtls=no_dtls,
            helper_path=str(helper_path),
        )

        _log(f"openconnect cmd: {' '.join(cmd)}")

        process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE if stdin_data is not None else None,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
        )
        self._openconnect_process = process

        if stdin_data is not None and process.stdin:
            try:
                process.stdin.write(stdin_data)
                process.stdin.flush()
            except Exception:
                pass
            try:
                process.stdin.close()
            except Exception:
                pass

        self._openconnect_output_thread = threading.Thread(
            target=self._openconnect_output_worker,
            args=(process, connection_uuid, protocol),
            name="ms-sso-openconnect-openconnect-output",
            daemon=True,
        )
        self._openconnect_output_thread.start()

        deadline = time.time() + CONNECT_TIMEOUT_SECONDS
        while time.time() < deadline and not self._connect_cancel.is_set():
            if self._ip_config_event.is_set():
                _log("Tunnel configuration received")
                return True
            if process.poll() is not None:
                break
            time.sleep(0.2)

        if self._ip_config_event.is_set():
            return True

        if process.poll() is None:
            _log("openconnect did not provide config in time; terminating")
            self._terminate_openconnect()

        return False

    def _openconnect_output_worker(
        self, process: subprocess.Popen[str], connection_uuid: str, protocol: str
    ) -> None:
        had_ip_config = False
        try:
            if not process.stdout:
                return
            for line in process.stdout:
                line = line.rstrip("\n")
                if line:
                    _log(f"openconnect: {line}")

                if protocol == "gp" and "portal-userauthcookie=" in line:
                    match = self._portal_cookie_re.search(line)
                    if not match:
                        continue
                    cookie = match.group(1)
                    if cookie and cookie.lower() != "empty":
                        _log("Captured portal-userauthcookie; updating cache")
                        _write_cookie_cache(
                            connection_uuid,
                            {"portal-userauthcookie": cookie},
                            "portal:portal-userauthcookie",
                        )

                if self._ip_config_event.is_set():
                    had_ip_config = True
        finally:
            returncode = process.wait()
            _log(f"openconnect exited with code {returncode}")
            self._openconnect_process = None
            if self._connect_cancel.is_set():
                return

            # Only report failures/stop once the VPN was actually configured.
            # During connection setup we may intentionally retry (e.g., cached cookie expired).
            if had_ip_config or self._ip_config_event.is_set() or _ip_config_ready_state(self.props.state):
                if returncode != 0:
                    GLib.idle_add(self.failure, NM.VpnPluginFailure.CONNECT_FAILED)
                GLib.idle_add(self._set_stopped)

    def _build_openconnect_command(
        self,
        *,
        gateway: str,
        protocol: str,
        username: Optional[str],
        cookies: dict,
        cached_usergroup: Optional[str],
        no_dtls: bool,
        helper_path: str,
    ) -> tuple[list[str], Optional[str]]:
        proto_flag = {"anyconnect": "anyconnect", "gp": "gp"}.get(protocol, "anyconnect")

        stdin_data: Optional[str] = None

        if protocol == "gp":
            gp_cookie_type: Optional[str] = None

            if cached_usergroup:
                gp_cookie_type = cached_usergroup
                if "portal-userauthcookie" in cookies:
                    cookie_str = cookies["portal-userauthcookie"]
                elif "prelogin-cookie" in cookies:
                    cookie_str = cookies["prelogin-cookie"]
                else:
                    cookie_str = "; ".join([f"{k}={v}" for k, v in cookies.items()])
            elif "prelogin-cookie" in cookies:
                cookie_str = cookies["prelogin-cookie"]
                gp_cookie_type = "portal:prelogin-cookie"
            elif "portal-userauthcookie" in cookies:
                cookie_str = cookies["portal-userauthcookie"]
                gp_cookie_type = "portal:portal-userauthcookie"
            else:
                cookie_str = "; ".join([f"{k}={v}" for k, v in cookies.items()])
                gp_cookie_type = "portal:portal-userauthcookie"

            use_stdin_cookie = "prelogin-cookie" in cookies

            cmd = [
                "openconnect",
                "--verbose",
                f"--protocol={proto_flag}",
                f"--script={helper_path}",
            ]
            if no_dtls:
                cmd.append("--no-dtls")

            cmd.extend(["--useragent=PAN GlobalProtect", "--os=linux-64"])
            if username:
                cmd.append(f"--user={username}")
            if gp_cookie_type:
                cmd.append(f"--usergroup={gp_cookie_type}")

            if use_stdin_cookie:
                cmd.extend(["--passwd-on-stdin", gateway])
                stdin_data = f"{cookie_str}\n"
            else:
                cmd.extend([f"--cookie={cookie_str}", gateway])

            return cmd, stdin_data

        cookie_str = "; ".join([f"{k}={v}" for k, v in cookies.items()])
        cmd = [
            "openconnect",
            "--verbose",
            f"--protocol={proto_flag}",
            f"--script={helper_path}",
        ]
        if no_dtls:
            cmd.append("--no-dtls")
        cmd.extend([f"--cookie={cookie_str}", gateway])
        return cmd, None

    def _parse_connection(self, connection: NM.Connection) -> Optional[dict[str, Any]]:
        s_vpn = connection.get_setting_vpn()
        if not s_vpn:
            return None

        connection_uuid = self._get_connection_uuid(connection)
        if not connection_uuid:
            return None

        gateway = s_vpn.get_data_item(DATA_KEY_GATEWAY) or ""
        protocol = s_vpn.get_data_item(DATA_KEY_PROTOCOL) or DEFAULT_PROTOCOL
        username = s_vpn.get_data_item(DATA_KEY_USERNAME) or ""
        no_dtls = (s_vpn.get_data_item(DATA_KEY_NO_DTLS) or "").lower() in {"1", "true", "yes", "on"}

        password = s_vpn.get_secret(SECRET_KEY_PASSWORD) or ""
        totp_secret = s_vpn.get_secret(SECRET_KEY_TOTP_SECRET) or ""

        if not gateway or not username or not password or not totp_secret:
            return None

        if protocol not in {"anyconnect", "gp"}:
            protocol = DEFAULT_PROTOCOL

        return {
            "uuid": connection_uuid,
            "gateway": gateway,
            "protocol": protocol,
            "username": username,
            "password": password,
            "totp_secret": totp_secret,
            "no_dtls": no_dtls,
        }


def _install_signal_handlers(service: MsSsoOpenConnectService, loop: GLib.MainLoop) -> None:
    def _handler(signum: int, _frame: object) -> None:
        _log(f"Signal {signum} received, shutting down")
        try:
            service.do_disconnect()
        except Exception:
            pass
        loop.quit()

    signal.signal(signal.SIGTERM, _handler)
    signal.signal(signal.SIGINT, _handler)


def main() -> int:
    service = MsSsoOpenConnectService()
    loop = GLib.MainLoop()
    _install_signal_handlers(service, loop)
    _log("Service started")
    loop.run()
    _log("Service stopped")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
